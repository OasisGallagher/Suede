// Warning: this file is generated by wrapper.py.

#pragma once

#include "component.h"

#include "lua++.h"
#include "tools/string.h"

class Component_Wrapper {
	static int ToString(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);

		lua_pushstring(L, String::Format("Component@0x%p", _p.get()).c_str());
		return 1;
	}

	static int ToStringStatic(lua_State* L) {
		lua_pushstring(L, "static Component");
		return 1;
	}

	static int ComponentStatic(lua_State* L) {
		lua_newtable(L);

		luaL_Reg funcs[] = {
			{ "GetComponentGUID", GetComponentGUID },
			{ "ClassNameToGUID", ClassNameToGUID },
			{"__tostring", ToStringStatic },
			{ nullptr, nullptr }
		};

		luaL_setfuncs(L, funcs, 0);

		return 1;
	}
	// virtual void Awake()
	static int Awake(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		_p->Awake();
		return 0;
	}

	// virtual void Update()
	static int Update(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		_p->Update();
		return 0;
	}

	// virtual void OnRenderImage(RenderTexture src, RenderTexture dest, const Rect& normalizedRect)
	static int OnRenderImage(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		Rect normalizedRect = Lua::get<Rect>(L, 4);
		RenderTexture dest = Lua::get<RenderTexture>(L, 3);
		RenderTexture src = Lua::get<RenderTexture>(L, 2);
		
		_p->OnRenderImage(src, dest, normalizedRect);
		return 0;
	}

	// bool GetEnabled()
	static int GetEnabled(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->GetEnabled());
	}

	// void SetEnabled(bool value)
	static int SetEnabled(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		bool value = Lua::get<bool>(L, 2);
		
		_p->SetEnabled(value);
		return 0;
	}

	// void SetGameObject(GameObject value)
	static int SetGameObject(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		GameObject value = Lua::get<GameObject>(L, 2);
		
		_p->SetGameObject(value);
		return 0;
	}

	// GameObject GetGameObject()
	static int GetGameObject(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->GetGameObject());
	}

	// Transform GetTransform()
	static int GetTransform(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->GetTransform());
	}

	// void CullingUpdate()
	static int CullingUpdate(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		_p->CullingUpdate();
		return 0;
	}

	// int GetUpdateStrategy()
	static int GetUpdateStrategy(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->GetUpdateStrategy());
	}

	// static suede_guid GetComponentGUID()
	static int GetComponentGUID(lua_State* L) {
		return Lua::push(L, IComponent::GetComponentGUID());
	}

	// static suede_guid ClassNameToGUID(const char* className)
	static int ClassNameToGUID(lua_State* L) {
		std::string className = Lua::get<std::string>(L, 1);
		
		return Lua::push(L, IComponent::ClassNameToGUID(className.c_str()));
	}

	// virtual bool AllowMultiple()
	static int AllowMultiple(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->AllowMultiple());
	}

	// virtual bool HideInInspector()
	static int HideInInspector(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->HideInInspector());
	}

	// virtual bool IsComponentType(suede_guid guid) const { return guid == GetComponentGUID()
	// virtual bool IsComponentType(const char* name) const { return strcmp(name, GetComponentName())
	static int IsComponentType(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		if (Lua::checkArguments<suede_guid>(L, 2)) {
			suede_guid guid = Lua::get<suede_guid>(L, 2);
			
			return Lua::push(L, _p->IsComponentType(guid));
		}

		if (Lua::checkArguments<std::string>(L, 2)) {
			std::string name = Lua::get<std::string>(L, 2);
			
			return Lua::push(L, _p->IsComponentType(name.c_str()));
		}

		Debug::LogError("failed to call \"IsComponentType\", invalid arguments.");
		return 0;
	}

	// virtual suede_guid GetComponentInstanceGUID() const { return GetComponentGUID()
	static int GetComponentInstanceGUID(lua_State* L) {
		Component& _p = *Lua::callerIntrusivePtr<Component>(L);
		return Lua::push(L, _p->GetComponentInstanceGUID());
	}

public:
	static void create(lua_State* L) {
		Lua::createMetatable<Component>(L);
	}
	
	static void initialize(lua_State* L, std::vector<luaL_Reg>& funcs, std::vector<luaL_Reg>& fields) {
		fields.push_back(luaL_Reg{ "Component", ComponentStatic });

		luaL_Reg metalib[] = {
			{ "__gc", Lua::deleteIntrusivePtr<Component> },
			{ "__tostring", ToString }, 
			{ "Awake", Awake },
			{ "Update", Update },
			{ "OnRenderImage", OnRenderImage },
			{ "GetEnabled", GetEnabled },
			{ "SetEnabled", SetEnabled },
			{ "SetGameObject", SetGameObject },
			{ "GetGameObject", GetGameObject },
			{ "GetTransform", GetTransform },
			{ "CullingUpdate", CullingUpdate },
			{ "GetUpdateStrategy", GetUpdateStrategy },
			{ "AllowMultiple", AllowMultiple },
			{ "HideInInspector", HideInInspector },
			{ "IsComponentType", IsComponentType },
			{ "GetComponentInstanceGUID", GetComponentInstanceGUID },
			{ nullptr, nullptr }
		};

		Lua::initMetatable<Component>(L, metalib, TypeID<Object>::string());
	}
};

class ComponentUtility_Wrapper {
	static int ToString(lua_State* L) {
		ComponentUtility* _p = Lua::callerPtr<ComponentUtility>(L);

		lua_pushstring(L, String::Format("ComponentUtility@0x%p", _p).c_str());
		return 1;
	}

public:
	static void create(lua_State* L) {
		Lua::createMetatable<ComponentUtility>(L);
	}
	
	static void initialize(lua_State* L, std::vector<luaL_Reg>& funcs, std::vector<luaL_Reg>& fields) {
		luaL_Reg metalib[] = {
			{ "__gc", Lua::deletePtr<ComponentUtility> },
			{ "__tostring", ToString }, 
			{ nullptr, nullptr }
		};

		Lua::initMetatable<ComponentUtility>(L, metalib, nullptr);
	}
};
