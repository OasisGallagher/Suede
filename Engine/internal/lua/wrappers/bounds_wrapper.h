// Warning: this file is generated by wrapper.py.

#pragma once

#include "bounds.h"

#include "lua++.h"
#include "tools/string.h"

class Bounds_Wrapper {
	static int NewBounds(lua_State* L) {
		if (Lua::checkArguments(L, 1)) {
			return Lua::newObject<Bounds>(L);
		}

		if (Lua::checkArguments<glm::vec3, glm::vec3>(L, 1)) {
			glm::vec3 size = Lua::get<glm::vec3>(L, 2);
			glm::vec3 center = Lua::get<glm::vec3>(L, 1);
		
			return Lua::newObject<Bounds>(L, center, size);
		}

		Debug::LogError("failed to call \"Bounds\", invalid arguments.");
		return 0;
	}

	static int ToString(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);

		lua_pushstring(L, String::Format("Bounds@0x%p", _p).c_str());
		return 1;
	}

	// bool IsEmpty()
	static int IsEmpty(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		return Lua::push(L, _p->IsEmpty());
	}

	// void Clear()
	static int Clear(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		_p->Clear();
		return 0;
	}

	// void Encapsulate(const Bounds& other)
	// void Encapsulate(const glm::vec3& point)
	static int Encapsulate(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);

		if (Lua::checkArguments<Bounds>(L, 2)) {
			Bounds other = Lua::get<Bounds>(L, 2);
			
			_p->Encapsulate(other);
			return 0;
		}

		if (Lua::checkArguments<glm::vec3>(L, 2)) {
			glm::vec3 point = Lua::get<glm::vec3>(L, 2);
			
			_p->Encapsulate(point);
			return 0;
		}

		Debug::LogError("failed to call \"Encapsulate\", invalid arguments.");
		return 0;
	}

	// void SetMinMax(const glm::vec3& min, const glm::vec3& max)
	static int SetMinMax(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		glm::vec3 max = Lua::get<glm::vec3>(L, 3);
		glm::vec3 min = Lua::get<glm::vec3>(L, 2);
		
		_p->SetMinMax(min, max);
		return 0;
	}

	// void Expand(const glm::vec3& amount)
	static int Expand(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		glm::vec3 amount = Lua::get<glm::vec3>(L, 2);
		
		_p->Expand(amount);
		return 0;
	}

	// void Translate(const glm::vec3& amount)
	static int Translate(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		glm::vec3 amount = Lua::get<glm::vec3>(L, 2);
		
		_p->Translate(amount);
		return 0;
	}

	// glm::vec3 GetMin()
	static int GetMin(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		return Lua::push(L, _p->GetMin());
	}

	// glm::vec3 GetMax()
	static int GetMax(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		return Lua::push(L, _p->GetMax());
	}

	// glm::vec3 GetSize()
	static int GetSize(lua_State* L) {
		Bounds* _p = Lua::callerPtr<Bounds>(L);
		return Lua::push(L, _p->GetSize());
	}

public:
	static void create(lua_State* L) {
		Lua::createMetatable<Bounds>(L);
	}
	
	static void initialize(lua_State* L, std::vector<luaL_Reg>& funcs, std::vector<luaL_Reg>& fields) {
		funcs.push_back(luaL_Reg { "NewBounds", NewBounds });

		luaL_Reg metalib[] = {
			{ "__gc", Lua::deletePtr<Bounds> },
			{ "__tostring", ToString }, 
			{ "IsEmpty", IsEmpty },
			{ "Clear", Clear },
			{ "Encapsulate", Encapsulate },
			{ "SetMinMax", SetMinMax },
			{ "Expand", Expand },
			{ "Translate", Translate },
			{ "GetMin", GetMin },
			{ "GetMax", GetMax },
			{ "GetSize", GetSize },
			{ nullptr, nullptr }
		};

		Lua::initMetatable<Bounds>(L, metalib, nullptr);
	}
};
