// Warning: this file is generated by wrapper.py.

#pragma once

#include "gameobject.h"

#include "lua++.h"
#include "tools/string.h"

class GameObject_Wrapper {
	static int NewGameObject(lua_State* L) {
		return Lua::fromShared(L, ::NewGameObject());
	}

	static int ToString(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);

		lua_pushstring(L, String::Format("GameObject@0x%p", _p.get()).c_str());
		return 1;
	}

	// bool GetActive()
	static int GetActive(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		return Lua::push(L, _p->GetActive());
	}

	// void SetActiveSelf(bool value)
	static int SetActiveSelf(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		bool value = Lua::get<bool>(L, 2);
		
		_p->SetActiveSelf(value);
		return 0;
	}

	// bool GetActiveSelf()
	static int GetActiveSelf(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		return Lua::push(L, _p->GetActiveSelf());
	}

	// int GetUpdateStrategy()
	static int GetUpdateStrategy(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		return Lua::push(L, _p->GetUpdateStrategy());
	}

	// bool SetTag(const std::string& value)
	static int SetTag(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		std::string value = Lua::get<std::string>(L, 2);
		
		return Lua::push(L, _p->SetTag(value));
	}

	// void Update()
	static int Update(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		_p->Update();
		return 0;
	}

	// void CullingUpdate()
	static int CullingUpdate(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		_p->CullingUpdate();
		return 0;
	}

	// Transform GetTransform()
	static int GetTransform(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		return Lua::push(L, _p->GetTransform());
	}

	// void RecalculateBounds(int flags = RecalculateBoundsFlagsAll)
	static int RecalculateBounds(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		if (Lua::checkArguments<int>(L, 2)) {
			int flags = Lua::get<int>(L, 2);
			
			_p->RecalculateBounds(flags);
			return 0;
		}

		if (Lua::checkArguments(L, 2)) {
			_p->RecalculateBounds();
			return 0;
		}

		Debug::LogError("failed to call \"RecalculateBounds\", invalid arguments.");
		return 0;
	}

	// void RecalculateUpdateStrategy()
	static int RecalculateUpdateStrategy(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		_p->RecalculateUpdateStrategy();
		return 0;
	}

	// Component AddComponent(const char* name)
	// Component AddComponent(Component component)
	static int AddComponent(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		if (Lua::checkArguments<std::string>(L, 2)) {
			std::string name = Lua::get<std::string>(L, 2);
			
			return Lua::push(L, _p->AddComponent(name.c_str()));
		}

		if (Lua::checkArguments<Component>(L, 2)) {
			Component component = Lua::get<Component>(L, 2);
			
			return Lua::push(L, _p->AddComponent(component));
		}

		Debug::LogError("failed to call \"AddComponent\", invalid arguments.");
		return 0;
	}

	// Component GetComponent(suede_guid guid)
	// Component GetComponent(const char* name)
	static int GetComponent(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		if (Lua::checkArguments<suede_guid>(L, 2)) {
			suede_guid guid = Lua::get<suede_guid>(L, 2);
			
			return Lua::push(L, _p->GetComponent(guid));
		}

		if (Lua::checkArguments<std::string>(L, 2)) {
			std::string name = Lua::get<std::string>(L, 2);
			
			return Lua::push(L, _p->GetComponent(name.c_str()));
		}

		Debug::LogError("failed to call \"GetComponent\", invalid arguments.");
		return 0;
	}

	// std::vector<Component> GetComponents(suede_guid guid)
	// std::vector<Component> GetComponents(const char* name)
	static int GetComponents(lua_State* L) {
		GameObject& _p = *Lua::callerSharedPtr<GameObject>(L);
		if (Lua::checkArguments<suede_guid>(L, 2)) {
			suede_guid guid = Lua::get<suede_guid>(L, 2);
			
			return Lua::pushList(L, _p->GetComponents(guid));
		}

		if (Lua::checkArguments<std::string>(L, 2)) {
			std::string name = Lua::get<std::string>(L, 2);
			
			return Lua::pushList(L, _p->GetComponents(name.c_str()));
		}

		Debug::LogError("failed to call \"GetComponents\", invalid arguments.");
		return 0;
	}

public:
	static void create(lua_State* L) {
		Lua::createMetatable<GameObject>(L);
	}
	
	static void initialize(lua_State* L, std::vector<luaL_Reg>& funcs, std::vector<luaL_Reg>& fields) {
		funcs.push_back(luaL_Reg { "NewGameObject", NewGameObject });

		luaL_Reg metalib[] = {
			{ "__gc", Lua::deleteSharedPtr<GameObject> },
			{ "__tostring", ToString }, 
			{ "GetActive", GetActive },
			{ "SetActiveSelf", SetActiveSelf },
			{ "GetActiveSelf", GetActiveSelf },
			{ "GetUpdateStrategy", GetUpdateStrategy },
			{ "SetTag", SetTag },
			{ "Update", Update },
			{ "CullingUpdate", CullingUpdate },
			{ "GetTransform", GetTransform },
			{ "RecalculateBounds", RecalculateBounds },
			{ "RecalculateUpdateStrategy", RecalculateUpdateStrategy },
			{ "AddComponent", AddComponent },
			{ "GetComponent", GetComponent },
			{ "GetComponents", GetComponents },
			{ nullptr, nullptr }
		};

		Lua::initMetatable<GameObject>(L, metalib, TypeID<Object>::string());
	}
};
