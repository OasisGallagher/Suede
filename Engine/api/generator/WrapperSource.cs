using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

class WrapperCreater
{
	class Argument
	{
		public string type;
		public string value;
	}

	class Method : IComparable<Method>
	{
		public Method(string method)
		{
			Initialize(method.TrimEnd(invalidTailings));
		}

		public string Name
		{
			get { return name_; }
		}

		public string Return
		{
			get { return r_; }
		}

		public string DefBody
		{
			get
			{
				string answer = "";
				for (int i = 0; i < arguments_.Count; ++i)
				{
					if (i != 0) { answer = answer + ", "; }
					answer += arguments_[i].type + " " + arguments_[i].value;
				}

				answer += ")";
				answer = name_ + "(" + answer;
				return answer;
			}
		}

		public string Def
		{
			get
			{
				return r_ + " " + DefBody;
			}
		}

		public List<Argument> Arguments
		{
			get { return arguments_; }
		}

		public int CompareTo(Method other)
		{
			return Name.CompareTo(other.Name);
		}

		void Initialize(string method)
		{
			int pointer = method.IndexOf("gl");

			r_ = method.Substring(0, pointer).Trim();

			// skip gl prefix.
			pointer += 2;

			int left = method.IndexOf('(');
			name_ = method.Substring(pointer, left - pointer).Trim();

			// skip '('.
			++left;

			string args = method.Substring(left, method.LastIndexOf(')') - left);
			if (string.IsNullOrEmpty(args))
			{
				return;
			}

			string[] list = null;
			if (!args.Contains(","))
			{
				list = new string[] { args };
			}
			else
			{
				list = args.Split(',');
			}
			
			foreach (string arg in list)
			{
				string trimed = arg.Trim();
				int space = trimed.LastIndexOf(' ');
				string type = trimed.Substring(0, space), value = trimed.Substring(space + 1);
				arguments_.Add(new Argument { type = type, value = value });
			}
		}

		string r_;
		string name_;

		List<Argument> arguments_ = new List<Argument>();

		static char[] invalidTailings = new char[] { ';', ' ', '\t' };
	}

	public WrapperCreater(string source)
	{
		StreamReader reader = new StreamReader(source);

		for (string line; (line = reader.ReadLine()) != null;)
		{
			methods.Add(new Method(line));
		}

		methods.Sort();
	}

	public int Create(string dest)
	{
		StreamWriter writer = new StreamWriter(dest, false);
		writer.WriteLine("// Warning: this file is generated by {0}.", Path.GetFileName(Process.GetCurrentProcess().MainModule.FileName));
		writer.WriteLine();
		
		AddHeaders(writer);
		AddDefines(writer);
		AddHelperMacros(writer);
		AddImplementations(writer);
		AddClearup(writer);

		writer.Close();

		return methods.Count;
	}

	void AddHeaders(StreamWriter writer)
	{
		writer.WriteLine("#pragma once");
		writer.WriteLine("#include <gl/glew.h>");
		writer.WriteLine();
		writer.WriteLine("#include \"debug/debug.h\"");
		writer.WriteLine("#include \"tools/string.h\"");
		writer.WriteLine();
	}

	void AddDefines(StreamWriter writer)
	{
		writer.WriteLine("class GL {");
		writer.WriteLine("public:");
		foreach (Method method in methods)
		{
			writer.WriteLine("\tstatic {0};", method.Def);
		}

		writer.WriteLine();
		writer.WriteLine("private:");

		writer.WriteLine("\tstatic void Verify(const char* func);");
		writer.WriteLine();

		writer.WriteLine("\ttemplate <class T>");
		writer.WriteLine("\tstatic T VerifyR(const char* func, T ans);");
		writer.WriteLine("};");
		writer.WriteLine();
	}

	void AddHelperMacros(StreamWriter writer)
	{
		writer.WriteLine(
@"#ifdef _DEBUG
#define GL_CALL(expression)		expression; Verify(__func__)
#define GL_CALL_R(expression)	return VerifyR(__func__, expression)
#else
#define GL_CALL(expression)		expression
#define GL_CALL_R(expression)	return expression
#endif
"
);

		writer.WriteLine(
@"inline void GL::Verify(const char* func) {
#define CASE(errorEnum)		case errorEnum: message = #errorEnum; break
	GLenum error = glGetError();
	std::string message;
	switch (error) {
		case GL_NO_ERROR:
			break;
		CASE(GL_INVALID_ENUM);
		CASE(GL_INVALID_VALUE);
		CASE(GL_INVALID_OPERATION);
		CASE(GL_STACK_OVERFLOW);
		CASE(GL_STACK_UNDERFLOW);
		CASE(GL_OUT_OF_MEMORY);
		CASE(GL_INVALID_FRAMEBUFFER_OPERATION);
		default: message = String::Format(""undefined error 0x % x"", error); break;
	}
#undef CASE

	if (!message.empty()) {
		Debug::LogError(""%s: %s."", func, message.c_str());
	}
}
"
);

		writer.WriteLine(
@"template <class T> inline
T GL::VerifyR(const char* func, T ans) {
	Verify(func);
	return ans;
}
"
);
	}

	void AddImplementations(StreamWriter writer)
	{
		foreach (Method method in methods)
		{
			writer.WriteLine("inline {0} GL::{1} {{", method.Return, method.DefBody);
			string line = "\t" + ((method.Return == "void") ? "GL_CALL" : "GL_CALL_R") + "(gl" + method.Name + "(";

			string arguments = "";
			for (int i = 0; i < method.Arguments.Count; ++i)
			{
				if (i != 0) { arguments = arguments + ", "; }
				arguments += method.Arguments[i].value;
			}

			line += arguments;
			line += "));";

			writer.WriteLine(line);
			writer.WriteLine("}");
			writer.WriteLine();
		}
	}

	void AddClearup(StreamWriter writer)
	{
		writer.WriteLine("#undef GL_CALL");
		writer.WriteLine("#undef GL_CALL_R");
		writer.WriteLine();
	}

	List<Method> methods = new List<Method>();
}

class Program
{
	static void Main(string[] args)
	{
		string input = "gl.txt", output = "../gl.h";
		if (args.Length > 0) { input = args[0]; }
		if (args.Length > 1) { input = args[1]; }

		string answer = "";
		for (; string.Compare(answer, "y", true) != 0 && string.Compare(answer, "n", true) != 0;)
		{
			Console.WriteLine("read from {0}, write to {1}, continue (y/n)?", input, output);
			try
			{
				answer = Console.ReadLine();
			}
			catch (OverflowException exception)
			{
				Console.Error.WriteLine(exception.Message);
				answer = null;
			}
		}

		if (string.Compare(answer, "y", true) == 0)
		{
			int count = 0;
			try
			{
				WrapperCreater creater = new WrapperCreater(input);
				count = creater.Create(output);
				Console.WriteLine("Success, {0} function generated.", count);
			}
			catch(Exception exception)
			{
				Console.Error.WriteLine(exception);
			}

			Console.ReadKey();
		}
	}
}
